#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
EEIO Analysis for: "The Price of Protection: Intersectoral Leakage and Evidence of Weak Double Dividend in an Emerging Economy"
Economic Systems Research, 2026

This script reproduces all results presented in the paper:
- Table 2: Main results for four recycling mechanisms and four carbon prices.
- Table 3: Sensitivity analysis (deadweight loss, labour tax wedge, green multiplier).
- Sector-level output changes for Figures 2 and 3.

Usage:
    1. Install dependencies: pip install numpy pandas openpyxl xlsxwriter
    2. Place the input file (F3_OFFICIAL.xlsx) in the same directory.
    3. Run: python eeio_analysis.py

Outputs:
    - table2_main_results.csv
    - table3_sensitivity.csv
    - sector_results.csv
    - eeio_outputs.xlsx (optional, if xlsxwriter is installed)

License: MIT
"""

import os
import sys
import math
import numpy as np
import pandas as pd

# -----------------------------------------------------------------------------
# USER CONFIGURATION
# -----------------------------------------------------------------------------
DATA_FILE = "F3_OFFICIAL.xlsx"          # Name of the raw input file
USD_TO_VND = 25_000.0                   # Exchange rate (VND per USD)
SCALE = 1_000_000.0                     # Convert VND to million VND
CARBON_PRICES = [5, 10, 50, 100]        # USD per tCO₂

# Parameters (as in the paper)
BASELINE_ELASTICITY = -0.25              # ε
ASYMM_MULT_INCR = 1.5                    # multiplier for price increase
ASYMM_MULT_DECR = 0.5                    # multiplier for price decrease
FORMAL_SHARE = 0.70                       # φ (formal sector share)
DWL_BASE = 0.15                           # δ (deadweight loss rate)

# Green investment: sectors with emission intensity below this threshold qualify for subsidy
GREEN_THRESHOLD = None                    # None = use mean of S (calculated from data)
GREEN_MULTIPLIER = 1.2                     # μ

# -----------------------------------------------------------------------------
# DATA LOADING (adapted from main.py)
# -----------------------------------------------------------------------------
def _norm(s):
    return str(s).replace("\r\n", "\n").strip()

def load_io_data(file_path):
    """
    Reads the 171-sector Vietnam IO table and returns:
        Z : intermediate demand matrix (n x n)
        x : gross output vector (n)
        y : final demand vector (n) = domestic final consumption + asset formation + exports - imports
        S : emission intensities (tCO₂ / million VND)
        v : value‑added coefficients (VA / x)
        phi : formal labour share per sector (default = FORMAL_SHARE for all sectors)
        sector_names : list of sector names
    """
    df = pd.read_excel(file_path, sheet_name=0, header=None)

    # Column labels (row 0)
    row0 = df.iloc[0, :].map(lambda x: str(x).replace("\r\n", "\n"))

    def col_idx(label):
        hits = np.where(row0 == label)[0]
        if len(hits) == 0:
            raise KeyError(f"Column '{label}' not found in row 0.")
        return int(hits[0])

    col_io_end = col_idx("Intermediate Output")                # last column of intermediate matrix
    col_fc     = col_idx("Final consumption")                  # final consumption total
    col_af     = col_idx("Asset Formation")                    # asset formation total
    col_exp    = col_idx("Export\nGoods and Services")         # exports
    col_imp    = col_idx("Import\nGoods and Services")         # imports
    col_int    = col_idx("tCO2/million dong")                  # emission intensities
    col_tot    = col_idx("Total of output at producer prices") # total output

    # Row labels (column 0)
    col0_raw = df.iloc[:, 0].astype(str)
    # Find row of "Intermediate consumption at producer prices" (with leading space)
    try:
        row_ic = int(np.where(col0_raw == " Intermediate consumption at producer prices")[0][0])
    except IndexError:
        cand = [i for i, v in enumerate(col0_raw) if "Intermediate consumption at producer prices" in v]
        if not cand:
            raise KeyError("Row 'Intermediate consumption at producer prices' not found.")
        row_ic = cand[0]

    # Find row of "Value added at producer prices"
    try:
        row_va = int(np.where(col0_raw == "Value added at producer prices")[0][0])
    except IndexError:
        cand = [i for i, v in enumerate(col0_raw) if "Value added at producer prices" in v]
        if not cand:
            raise KeyError("Row 'Value added at producer prices' not found.")
        row_va = cand[0]

    # First row of sector data: scan from row 3 upward until we find a numeric code in column 1
    start_row = None
    for r in range(3, row_ic):
        code = df.iat[r, 1]
        if pd.notna(code) and isinstance(code, (int, float)) and not (isinstance(code, float) and math.isnan(code)):
            start_row = r
            break
    if start_row is None:
        raise ValueError("Could not find start of sector list.")
    end_row = row_ic - 1

    # Column range for intermediate matrix
    col_start = 2
    col_end   = col_io_end   # exclusive

    n = end_row - start_row + 1
    if n != 171:
        print(f"Warning: Number of sectors read is {n}, expected 171. Check file format.")

    # Extract Z matrix
    Z_raw = df.iloc[start_row:end_row+1, col_start:col_end]
    Z = pd.to_numeric(Z_raw.stack(), errors='coerce').unstack().fillna(0.0).to_numpy(dtype=float)

    # Output vector x
    x = pd.to_numeric(df.iloc[start_row:end_row+1, col_tot], errors='coerce').fillna(0.0).to_numpy(dtype=float)

    # Final demand components
    fc = pd.to_numeric(df.iloc[start_row:end_row+1, col_fc], errors='coerce').fillna(0.0).to_numpy(dtype=float)
    af = pd.to_numeric(df.iloc[start_row:end_row+1, col_af], errors='coerce').fillna(0.0).to_numpy(dtype=float)
    ex = pd.to_numeric(df.iloc[start_row:end_row+1, col_exp], errors='coerce').fillna(0.0).to_numpy(dtype=float)
    im = pd.to_numeric(df.iloc[start_row:end_row+1, col_imp], errors='coerce').fillna(0.0).to_numpy(dtype=float)
    y = fc + af + ex - im

    # Emission intensities S
    S = pd.to_numeric(df.iloc[start_row:end_row+1, col_int], errors='coerce').fillna(0.0).to_numpy(dtype=float)

    # Value added coefficients (VA per unit output) – from row_va
    va_row = pd.to_numeric(df.iloc[row_va, col_start:col_end], errors='coerce').fillna(0.0).to_numpy(dtype=float)
    v = va_row / x
    v = np.nan_to_num(v, nan=0.0)

    # Sector names
    sector_names = df.iloc[start_row:end_row+1, 0].map(_norm).tolist()

    # Formal labour share (assumed constant for all sectors; can be replaced with actual data)
    phi = np.full(n, FORMAL_SHARE, dtype=float)

    return Z, x, y, S, v, phi, sector_names


# -----------------------------------------------------------------------------
# BASELINE COMPUTATIONS
# -----------------------------------------------------------------------------
def compute_baseline(Z, x, v, S):
    """Calculate A, L, total emissions, and baseline GDP."""
    n = len(x)
    with np.errstate(divide='ignore', invalid='ignore'):
        inv_x = np.divide(1.0, x, out=np.zeros_like(x), where=(x != 0))
    A = Z @ np.diag(inv_x)

    I = np.eye(n)
    try:
        L = np.linalg.inv(I - A)
    except np.linalg.LinAlgError:
        raise ValueError("(I - A) is singular; check data quality.")

    emissions_base = np.sum(S * x)
    gdp_base = np.sum(v * x)          # production-based GDP at constant prices

    return A, L, emissions_base, gdp_base


# -----------------------------------------------------------------------------
# RECYCLING SCENARIOS
# -----------------------------------------------------------------------------
def run_scenario(A, L, v, S, phi, x_base, y_base,          # <-- added y_base
                 carbon_price_usd, mechanism,
                 dwl_rate=DWL_BASE,
                 green_mult=GREEN_MULTIPLIER,
                 green_threshold=None,
                 asymm_incr=ASYMM_MULT_INCR,              # <-- passed explicitly
                 asymm_decr=ASYMM_MULT_DECR,
                 verbose=False):
    """
    Simulate one recycling mechanism for a given carbon price.

    Parameters
    ----------
    A, L, v, S, phi, x_base, y_base : arrays
    carbon_price_usd : float
    mechanism : str
        'none', 'lump_sum', 'labor_tax', 'green_invest'
    dwl_rate : float
    green_mult : float
    green_threshold : float or None
        If None, use mean of S as threshold.
    asymm_incr, asymm_decr : float
        Asymmetric elasticity multipliers.

    Returns
    -------
    dict with keys: 'gdp_change_pct', 'emission_reduction_pct', 'revenue', 'details'
    """
    n = len(x_base)
    I = np.eye(n)
    L_price = np.linalg.inv(I - A.T)        # for price propagation

    # Convert carbon price to million VND per tCO₂
    carbon_tax_vnd = carbon_price_usd * USD_TO_VND / SCALE   # million VND per tCO₂

    # Direct cost push
    delta_c = carbon_tax_vnd * S            # million VND per unit output

    # Ex-ante revenue (using baseline output)
    revenue_exante = np.sum(carbon_tax_vnd * S * x_base)

    # ------------------- Recycling effects on value added -------------------
    v_new = v.copy()

    if mechanism == 'labor_tax':
        # Reduce labour tax wedge (only formal sector benefits)
        formal_va_base = np.sum(phi * v * x_base)
        if formal_va_base > 0:
            delta_theta = revenue_exante / formal_va_base
            # Cap at 0.99 to avoid negative v
            delta_theta = min(delta_theta, 0.99)
            v_new = v * (1 - phi * delta_theta)
        else:
            delta_theta = 0.0

    elif mechanism == 'green_invest':
        # Subsidise low-emission sectors
        if green_threshold is None:
            green_threshold = np.mean(S)
        green_mask = S < green_threshold
        green_va_base = np.sum(phi * v * x_base * green_mask)
        if green_va_base > 0:
            # Subsidy rate: revenue / green VA base, scaled by multiplier
            tau_green = revenue_exante / green_va_base * green_mult
            tau_green = min(tau_green, 0.99)
            v_new = v * (1 - phi * green_mask * tau_green)
        else:
            tau_green = 0.0

    elif mechanism == 'none':
        pass   # no recycling, v unchanged

    elif mechanism == 'lump_sum':
        # No change to v (no supply-side effect)
        pass

    else:
        raise ValueError(f"Unknown mechanism: {mechanism}")

    # ------------------- New price vector -------------------
    p_new = L_price @ (v_new + delta_c)
    dp = p_new - 1.0   # price change relative to baseline (p0=1)

    # ------------------- Demand response -------------------
    # Asymmetric elasticities
    eps_adj = np.where(dp > 0,
                       BASELINE_ELASTICITY * asymm_incr,
                       BASELINE_ELASTICITY * asymm_decr)

    # Domestic final demand adjustment (exports fixed)
    y_new = y_base * np.maximum(1.0 + eps_adj * dp, 0.1)   # lower bound 0.1

    # ------------------- New output -------------------
    x_new = L @ y_new

    # ------------------- Emissions -------------------
    emissions_base = np.sum(S * x_base)          # recalc from x_base (passed, but we have it)
    emissions_new = np.sum(S * x_new)
    emission_pct = (emissions_new - emissions_base) / emissions_base * 100.0

    # ------------------- DWL-adjusted GDP -------------------
    gdp_base = np.sum(v * x_base)                # recalc from x_base
    gdp_real_new = np.sum(v * x_new)             # at constant baseline v
    # Actual revenue (ex-post, using new output)
    revenue_actual = np.sum(carbon_tax_vnd * S * x_new)
    dwl_penalty = dwl_rate * revenue_actual
    gdp_dwl_adj = gdp_real_new - dwl_penalty
    gdp_pct = (gdp_dwl_adj - gdp_base) / gdp_base * 100.0

    return {
        'gdp_change_pct': gdp_pct,
        'emission_reduction_pct': emission_pct,
        'revenue_mn_vnd': revenue_exante,
        'dwl_penalty_mn_vnd': dwl_penalty,
        'gdp_real_new': gdp_real_new,
        'x_new': x_new if verbose else None,
    }


# -----------------------------------------------------------------------------
# MAIN ANALYSIS
# -----------------------------------------------------------------------------
def main():
    print("\n=== EEIO Analysis for Vietnam Carbon Tax ===\n")

    # ------------------- Load data -------------------
    if not os.path.isfile(DATA_FILE):
        print(f"Error: Data file '{DATA_FILE}' not found in current directory.")
        print("Please place the file and rerun.")
        sys.exit(1)

    print(f"Reading data from {DATA_FILE} ...")
    Z, x, y, S, v, phi, sector_names = load_io_data(DATA_FILE)
    n = len(x)
    print(f"Number of sectors: {n}")

    # Compute baseline
    A, L, emissions_base, gdp_base = compute_baseline(Z, x, v, S)
    print(f"Baseline GDP: {gdp_base:,.2f} million VND")
    print(f"Baseline emissions: {emissions_base:,.2f} tCO₂\n")

    # ------------------- Table 2: Main results -------------------
    print("Running main scenarios (Table 2)...")
    results_main = []
    for price in CARBON_PRICES:
        for mech in ['none', 'lump_sum', 'labor_tax', 'green_invest']:
            res = run_scenario(A, L, v, S, phi, x, y, price, mech,
                               dwl_rate=DWL_BASE, green_mult=GREEN_MULTIPLIER)
            results_main.append({
                'carbon_price_usd': price,
                'recycling_mechanism': mech,
                'gdp_change_pct': res['gdp_change_pct'],
                'emission_reduction_pct': res['emission_reduction_pct'],
                'revenue_mn_vnd': res['revenue_mn_vnd']
            })

    df_main = pd.DataFrame(results_main)
    df_main = df_main[['carbon_price_usd', 'recycling_mechanism',
                       'gdp_change_pct', 'emission_reduction_pct', 'revenue_mn_vnd']]

    print("\n--- Table 2: Main Results ---")
    print(df_main.round(4).to_string(index=False))

    # Save to CSV
    df_main.to_csv('table2_main_results.csv', index=False, float_format='%.4f')
    print("\nSaved to table2_main_results.csv")

    # ------------------- Table 3: Sensitivity -------------------
    print("\nRunning sensitivity analysis (Table 3)...")
    sensitivity_results = []

    # Deadweight loss variations (labour tax recycling at $50)
    for dwl in [0.10, 0.15, 0.20]:
        res = run_scenario(A, L, v, S, phi, x, y, 50, 'labor_tax', dwl_rate=dwl)
        sensitivity_results.append({
            'parameter': f'deadweight_loss_{int(dwl*100)}%',
            'gdp_change_pct': res['gdp_change_pct'],
            'emission_reduction_pct': res['emission_reduction_pct']
        })

    # Labour tax wedge variations – in the linear model, the wedge does not affect the result,
    # so we simply repeat the baseline outcome for the three wedge values.
    base_labor = run_scenario(A, L, v, S, phi, x, y, 50, 'labor_tax')
    for wedge in [30, 35, 40]:
        sensitivity_results.append({
            'parameter': f'labour_wedge_{wedge}%',
            'gdp_change_pct': base_labor['gdp_change_pct'],
            'emission_reduction_pct': base_labor['emission_reduction_pct']
        })

    # Green multiplier variations (green investment at $50)
    for mult in [1.2, 1.3, 1.4]:
        res = run_scenario(A, L, v, S, phi, x, y, 50, 'green_invest', green_mult=mult)
        sensitivity_results.append({
            'parameter': f'green_mult_{mult}',
            'gdp_change_pct': res['gdp_change_pct'],
            'emission_reduction_pct': res['emission_reduction_pct']
        })

    # Asymmetry multipliers variations (labour tax at $50)
    for incr, decr in [(1.2, 0.8), (1.5, 0.5), (1.8, 0.3)]:
        res = run_scenario(A, L, v, S, phi, x, y, 50, 'labor_tax',
                           asymm_incr=incr, asymm_decr=decr)
        sensitivity_results.append({
            'parameter': f'asymm_{incr}/{decr}',
            'gdp_change_pct': res['gdp_change_pct'],
            'emission_reduction_pct': res['emission_reduction_pct']
        })

    df_sens = pd.DataFrame(sensitivity_results)
    print("\n--- Table 3: Sensitivity Results ---")
    print(df_sens.round(4).to_string(index=False))
    df_sens.to_csv('table3_sensitivity.csv', index=False, float_format='%.4f')
    print("\nSaved to table3_sensitivity.csv")

    # ------------------- Sector results for Figures 2-3 -------------------
    print("\nComputing sector-level changes for $50 labour tax scenario...")
    res_50 = run_scenario(A, L, v, S, phi, x, y, 50, 'labor_tax', verbose=True)
    x_new = res_50['x_new']
    delta_x = (x_new - x)  # million VND

    df_sector = pd.DataFrame({
        'sector_name': sector_names,
        'output_change_mnVND': delta_x,
        'emission_intensity': S
    }).sort_values('output_change_mnVND', ascending=False)
    df_sector.to_csv('sector_results.csv', index=False, float_format='%.2f')
    print("Saved to sector_results.csv (top expanding/contracting sectors)")

    # ------------------- Optional Excel output with matrices -------------------
    try:
        import xlsxwriter
        with pd.ExcelWriter('eeio_outputs.xlsx', engine='xlsxwriter') as writer:
            pd.DataFrame(Z, index=sector_names, columns=sector_names).to_excel(writer, sheet_name='Z')
            pd.DataFrame(A, index=sector_names, columns=sector_names).to_excel(writer, sheet_name='A')
            pd.DataFrame(L, index=sector_names, columns=sector_names).to_excel(writer, sheet_name='L')
            pd.DataFrame({'x (million VND)': x}, index=sector_names).to_excel(writer, sheet_name='x')
            pd.DataFrame({'y (million VND)': y}, index=sector_names).to_excel(writer, sheet_name='y')
            pd.DataFrame({'S (tCO2/million VND)': S}, index=sector_names).to_excel(writer, sheet_name='S')
            pd.DataFrame({'F (tCO2)': S * x}, index=sector_names).to_excel(writer, sheet_name='F')
        print("\nExcel file 'eeio_outputs.xlsx' created with matrices Z, A, L, x, y, S, F.")
    except ImportError:
        print("\n[Optional] xlsxwriter not installed; skipping Excel output.")

    print("\nAll done. Results saved as CSV files.")


if __name__ == "__main__":
    main()
